/*

We wish to classify the axial algebras which are generated by 3 axes and have as automorphism groups a 4 transposition group.

This code builds all actions, tau-maps and shapes for such groups, ready to put into the Partial Axial Algebras code.

Let the algebra A be generated by axes a, b, and c.  To each of these is associated a Miyamoto involution x, y, z.  Hence the group is 3 generated (although sometimes this is a redundant set).  We begin by listing the possible groups.

*/

// This code uses the Partial Axial Algebras code.
AttachSpec("ParAxlAlg.spec");

// We run through the different cases for the products.  Some need more relations than others to get finite groups.  We continue splitting into subcases to get all of them.

G1<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^3, (x*z)^3, (y*z)^3,
               (x*y^z)^3>;
G2<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^3, (x*z)^3, (y*z)^3,
               (x*y^z)^4>;

G3<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^3, (x*z)^3, (y*z)^4,
               (x*y^z)^3>;
G4<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^3, (x*z)^3, (y*z)^4,
               (x*y^z)^4>;

G5<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^3, (x*z)^4, (y*z)^4,
               (x*y^z)^3, (x*z^y)^3>;
G6<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^3, (x*z)^4, (y*z)^4,
               (x*y^z)^3, (x*z^y)^4>;
G7<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^3, (x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^3>;
G8<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^3, (x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^4>;
GG , phi := PermutationGroup(G8);
assert Order((z*z^(x*y))@phi) eq 6;

G9<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4, (x*z)^4, (y*z)^4,
               (x*y^z)^3, (x*z^y)^3>;
G10<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4, (x*z)^4, (y*z)^4,
               (x*y^z)^3, (x*z^y)^4>;
GG , phi := PermutationGroup(G10);
assert Order((z*z^(x*y))@phi) eq 6;

G11<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4, (x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^3>;
GG , phi := PermutationGroup(G11);
assert Order((y*y^(x*z))@phi) eq 6;

G12<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4, (x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^4, (y*z^x)^3>;
GG , phi := PermutationGroup(G12);
assert Order((x*x^(y*z))@phi) eq 6;

G13<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4,(x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^4, (y*z^x)^4, (x*x^(y*z))^3>;
GG , phi := PermutationGroup(G13);
assert Order((y*y^(x*z))@phi) eq 6;

G14<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4,(x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^4, (y*z^x)^4, (x*x^(y*z))^4>;
GG , phi := PermutationGroup(G14);
assert Order((y*y^(x*z))@phi) eq 8;
assert Order((z*z^(x*y))@phi) eq 8;


function Is4TranspositionGroup(G)
  GG, phi := PermutationGroup(G);
  class := Orbit(GG, GG.1) join Orbit(GG, GG.2) join Orbit(GG, GG.3);

  for i in [1..3] do
    C := Centraliser(GG,GG.i);
    orbs := Orbits(C, GSet(C, class));
    so := forall(t){ <GG.i, g> : g in [o[1] : o in orbs] | Order(GG.i*g) le 4};
    if not so then
      return false, t;
    end if;
  end for;
  return true;
end function;

[ Is4TranspositionGroup(G) : G in [G1,G2,G3,G4,G5,G6,G7,G8,G9,G10,G11,G12,G13,G14]];

G8_1<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^3, (x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^4, (z*z^(x*y))^2>;
G8_2<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^3, (x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^4, (z*z^(x*y))^3>;

G10_1<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4, (x*z)^4, (y*z)^4,
               (x*y^z)^3, (x*z^y)^4, (z*z^(x*y))^2>;
G10_2<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4, (x*z)^4, (y*z)^4,
               (x*y^z)^3, (x*z^y)^4, (z*z^(x*y))^3>;

G11_1<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4, (x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^3, (y*y^(x*z))^2>;
G11_2<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4, (x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^3, (y*y^(x*z))^3>;

G12_1<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4, (x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^4, (y*z^x)^3, (x*x^(y*z))^2>;
G12_2<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4, (x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^4, (y*z^x)^3, (x*x^(y*z))^3>;

G13_1<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4,(x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^4, (y*z^x)^4, (x*x^(y*z))^3, (y*y^(x*z))^2>;
G13_2<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4,(x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^4, (y*z^x)^4, (x*x^(y*z))^3, (y*y^(x*z))^3>;


G14_1<x,y,z> := Group<x,y,z | x^2, y^2, z^2, (x*y)^4,(x*z)^4, (y*z)^4,
               (x*y^z)^4, (x*z^y)^4, (y*z^x)^4, (x*x^(y*z))^4, (y*y^(x*z))^4, (z*z^(x*y))^4>;

assert {true} eq { Is4TranspositionGroup(G) : G in [G8_1, G8_2,G10_1,G10_2,G11_1, G11_2,G12_1, G12_2,G13_1, G13_2,G14_1]};

// So we have found all the maximal 3 generated 4 transposition groups

[ Order(G) : G in [G8_1, G8_2,G10_1,G10_2,G11_1, G11_2,G12_1, G12_2,G13_1, G13_2,G14_1]];

G1 := PermutationGroup(G1);
G2 := PermutationGroup(G2);
G3 := PermutationGroup(G3);
G4 := PermutationGroup(G4);
G5 := PermutationGroup(G5);
G6 := PermutationGroup(G6);
G7 := PermutationGroup(G7);
G8_1 := PermutationGroup(G8_1);
G8_2 := PermutationGroup(G8_2);
G9 := PermutationGroup(G9);
G10_1 := PermutationGroup(G10_1);
G10_2 := PermutationGroup(G10_2);
G11_1 := PermutationGroup(G11_1);
G11_2 := PermutationGroup(G11_2);
G12_1 := PermutationGroup(G12_1);
G12_2 := PermutationGroup(G12_2);
G13_1 := PermutationGroup(G13_1);
G13_2 := PermutationGroup(G13_2);
G14_1 := PermutationGroup(G14_1);

// We only wish to consider groups which give the same algebra once.  So, the orbits of each axis under the group must be the same.  We call such groups similar.

IsAxialSimilar := function(G, H)
  so, phi := IsIsomorphic(G, H);
  if not so then
    return false;
  end if;

  // Check whether the two triples of generators can be mapped one onto the other
  Ggen := {* Orbit(G,G.i) : i in [1..3] *};
  S := {* Orbit(H, G.i@phi) : i in [1..3] *};

  Hgen := {* Orbit(H,H.i) : i in [1..3] *};

  // We only care about actions up to equivalence
  A := AutomorphismGroup(H);
  classes2 := [ tup : tup in ConjugacyClasses(H) | tup[1] le 2 ];
  invs := &join [Orbit(H,tup[3]) : tup in classes2];

  // We build the action of the automorphism group on the involutions.
  psi, AA := PermutationRepresentation(A);
  YxA := CartesianProduct(invs, AA);
  invs := GSet(AA, invs, map< YxA -> invs | t:-> t[1]@(t[2]@@psi)>);
  if S in Orbit(AA,invs,Hgen) then
    return true;
  else
    return false;
  end if;
end function;

more_groups := [G1,G2,G3,G4,G5,G6,G7,G8_1, G8_2,G9,G10_1,G10_2,G11_1, G11_2,G12_1, G12_2,G13_1, G13_2,G14_1];

// The big 2-group has order 8192
ord, pos := Max([Order(G) : G in more_groups]);
Big2 := more_groups[pos];

// The groups of order 2, 8 and 32 are quotients of the large 2-group, so we can remove these.
for G in more_groups do
  if not Order(G) in [2,8,32] then
    continue;
  end if;
  assert exists{N : N in NormalSubgroups(Big2: IndexEqual:= Order(G)) | IsIsomorphic(Big2/N`subgroup, G)};  
end for;

groups := [G : G in [G1,G2,G3,G4,G5,G6,G7,G8_1, G8_2,G9,G10_1,G10_2,G11_1, G11_2,G12_1, G12_2,G13_1, G13_2,G14_1] | Order(G) notin [2,8,32]];

// We filter the groups above for similarity.
max_groups := [];

for G in groups do
  for H in max_groups do
    if IsAxialSimilar(G, H) then
      continue G;
    end if;
  end for;
  Append(~max_groups, G);
end for;

assert #max_groups eq 7;

//  Now we look at these 7 groups and find all their quotients and make a list of these up to similarity.
all_groups := [];

for G in max_groups do
  norms := NormalSubgroups(G);
  for N in norms do
    K := G/(N`subgroup);
    // K.3 in Generators(K) join {Identity(K)};
    for H in all_groups do
      if IsAxialSimilar(H, K) then
        continue N;
      end if;
    end for;
    Append(~all_groups, K);
  end for;
end for;

assert #all_groups eq 55;

Sort(~all_groups, func<x,y|Order(x)-Order(y)>);

//----------------------------------------------------

// Now that we have the groups, for a given group
// we want to build all the minimal stabilisers

//----------------------------------------------------

// If an element x is not in O_2(G), then there is an involution y in x^G such that the order of xy is odd.  Since we have no 6A subalgebras, x is unique.  Corollary 4.5

IsUnique := function(G,x)
  if x in pCore(G,2) then  // the identity is not unique
    return false;
  else return true;
  end if;
end function;

// The stabiliser of an axis a in G contains the associated Miyamoto involution but is contained in the centraliser C_G(a).  We find the smallest possible stabiliser.  Then the axes conjugate to a are in bijection with the cosets of the stabiliser.

MinimalStabilisers := function(G)
  gens := GeneratorsSequence(G);
  invs := [ Orbit(G, g) : g in gens ];
  
  // Lemma 4.8(ii): If o(xt) = 4, then the orbit of D=<x,t> on a has length 1,2,or 4.  It is not 1 as x and t don't commute and it can't be 4, so it must be 2.  Therefore, (xt)^2 acts trivially and so is in G_a
  
  function BuildStabiliser(G, u)
    if IsIdentity(u) or IsUnique(G, u) then
      return Centraliser(G, u);
    else
      return sub<G| [u] cat [ (u*t)^2 : t in &join invs | Order(t*u) eq 4]>;
    end if;
  end function;
  
  minstab := [ BuildStabiliser(G, u) : u in gens];
  is_strong := [minstab[i] eq Centraliser(G, gens[i]) : i in [1..3]];

  // Use Lemma 4.8(i): if x is strong and o(xy) =2, then x in G_b ( called Cy here)
  // Nb if x is strong, then every involution in x^G is strong
  // Use Lemma 4.9: if x^g in G_b then y^{g^-1} in G_a
  sizes := [1,1,1];
  while [#H : H in minstab] ne sizes do
    sizes := [#H : H in minstab];
    
    for i in [1..3] do
      H := minstab[i];
      if is_strong[i] then
        continue i;
      end if;
      minstab[i] := sub<G | Generators(minstab[i]) join { t : t in invs[j], j in {1,2,3} | is_strong[j] and Order(t*gens[i]) eq 2 } join
                               { t : t in invs[j], j in {1,2,3} | Order(t*gens[i]) eq 2 and t notin minstab[i] and gens[i]^(g^-1) in minstab[j]
                                    where so, g := IsConjugate(G, gens[j], t)} >;
      is_strong[i] := minstab[i] eq Centraliser(G, gens[i]);  // update whether it is strong
    end for;
  end while;

  return minstab;
end function;
/*

Stats

*/
uniqueness := {* {* IsUnique(G, G.i) or IsIdentity(G.i) : i in [1..3]*} : G in all_groups*};

minstabs := [MinimalStabilisers(G) : G in all_groups];
Cents := [ [ Centraliser(G, G.i) : i in [1..3]] : G in all_groups];

strongness := {* {* minstabs[i,j] eq Cents[i,j] : j in [1..3] *} : i in [1..#all_groups]*};

indices := {* Index(Cents[i,j], minstabs[i,j]): j in [1..3], i in [1..#all_groups]*};

//----------------------------------------------------

/*

1) Build a set of all possible groups with a distinguished set of 3 generators

2) Dedupe appropriately

3) For each G and set [x,y,z] we want to find the possible orbits

If there exists an involution u in x^G \cup y^G \cup z^G such that o(xu) = 3, then the axis associated to x must be unique.  That is, there is only one axis such that it maps to x under the tau map.  So, G_a = C_G(x) and the orbit is conjugate to the orbit on cosets.

4) For each possible set of 3 orbits, see whether we can get 1, 2 or 3 orbits total and combine to get all possiblilities

*/

//----------------------------------------------------

// Given G, a generator x and the min centraliser Cx, build all possible stabilisers
function BuildAllStabilisers(G, Cx, x)
  C := Centraliser(G, x);
  // build the quotient
  Cbar, quo_map := quo<C|Cx>;
    
  poss := [ H`subgroup : H in Subgroups(Cbar) ];
  // We only need a representative from each conjugacy class
    
  subgroups := [];
  for H in poss do
    if not exists{ K : K in subgroups | IsConjugate(Cbar, H, K)} then
      Append(~subgroups, H);
    end if;
  end for;

  return [ K@@quo_map : K in subgroups];
end function;

// Build action of G on the cosets of H and also return tau map
function ConjugacyAction(G, H, x)
  assert H subset Centraliser(G, x);
 
  act, GG := CosetAction(G, H);
  GGAx := GSet(GG);
  Ax := IndexedSet([1..#GGAx]);
  AxxG := CartesianProduct(Ax, G);
  f := map< AxxG -> Ax | y :-> Image(y[2]@act, GGAx, y[1])>;
  Ax := GSet(G, Ax, f);
  
  // action is transitive, so we can build the tau map as follows
  tau := map<Ax -> G | i :-> i eq 1 select x else x^g where _, g := IsConjugate(G, Ax, 1, i)>;
  return Ax, tau;
end function;

function IsIsomorphicGSet(X, Y)
  if #X ne #Y then
    return false;
  end if;
  sym := Sym(#X);
  GX := ActionImage(Group(X), X);
  GY := ActionImage(Group(Y), Y);
  if not IsConjugate(sym, GX, GY) then
    return false;
  end if;
  return true;
end function;

function SumActions(X, tauX, Y, tauY)
  G := Group(X);
  assert G eq Group(Y);
  Ax := IndexedSet([1..#X+#Y]);
  AxxG := CartesianProduct(Ax, G);
  f := map< AxxG -> Ax | y :-> y[1] le #X select Image(y[2], X, y[1]) else Image(y[2], Y, y[1]-#X)+#X>;
  Ax := GSet(G, Ax, f);
  tau := map<Ax -> G | i :-> i le #X select i@tauX else (i-#X)@tauY>;
  return Ax, tau;
end function;

// We don't want to do the 2-generated axial algebras
dihedralAxs := [GSet(sub<Sym(2)|>), GSet(Sym(3)), GSet(DirectProduct(CyclicGroup(2), CyclicGroup(2))), GSet(sub<Sym(5)| [ Sym(5)|[1,3,2,5,4], [5,4,2,1,3]]>), GSet(sub<Sym(6)| [ Sym(6)|[2,3,1,5,6,4], [1,3,2,4,6,5]]>)];

// This appends to the list X, checking for duplicates and if it is a 2-generated axial algebra
procedure DedupeAppend(~X, x)
  if #x ge 3 and
    not exists{y : y in dihedralAxs | IsIsomorphicGSet(x, y)} and
    not exists{ y : y in X | IsIsomorphicGSet(x, y)} then
    Append(~X, x);
  end if;
end procedure;


function Has6A5A(Ax, tau)
  if #Ax eq 1 then return false;
  end if;
  // Check if Ax has any 5As or 6As
  G := Group(Ax);
  pairs_orbs := Orbits(G, GSet(G,Ax,{ {@i,j@} : j in [i+1..#Ax], i in [1..#Ax]}));
  pairs_orb_reps := [ Representative(o) : o in pairs_orbs];
  
  for pair in pairs_orb_reps do
    D := sub<G | pair[1]@tau, pair[2]@tau>;
    o1 := Orbit(D, Ax, pair[1]);
    o2 := Orbit(D, Ax, pair[2]);
    if o1 eq o2 and #o1 eq 5 then // 5A
      return true;
    elif o1 ne o2 and #o1 eq 3 then // 6A
      return true;
    end if;
  end for;
  
  return false;
end function;

function IsFaithfulAction(G, Hs)
  Int := &meet Hs;
  return not exists(N){ N`subgroup : N in NormalSubgroups(Int) | N`order ne 1 and IsNormal(G, N`subgroup)};
end function;

// Check stabiliser hasn't become all of G for a non-trivial Miyamoto involution
function StabiliserNotTooLarge(G, stab, s)
  return not exists(i){ i : i in [1..3] | s[i] ne G!1 and stab[i] eq G};
end function;
/*

Stats

*/
faithfulness := {* IsFaithfulAction(all_groups[i], minstabs[i]) : i in [1..#all_groups]*};




function BuildGX(S)
  not_faithful_min := 0;
  not_faithful_stab := 0;
  no_actions := 0;
  not_symmetric := 0;
  stab_too_large := 0;
  out := [];
  for k in [1..#S] do
    G := S[k];
    minstabs := MinimalStabilisers(G);
    printf "\nProcessing group number %o of %o\n", k, #S;
    
    if not IsFaithfulAction(G, minstabs) then
      print "No faithful actions.\n";
      not_faithful_min +:= 1;
      continue k;
    end if;    
    
    printf "Number of GSets already calculated is %o\n", #out;
    s := GeneratorsSequence(G);
    orbs := [ Orbit(G, s[i]) : i in [1..3]];
    
    axis_stabilisers := [ BuildAllStabilisers(G, minstabs[j], s[j]) : j in [1..3]];

    // The action is faithful if and only if G_a \cap G_b \cap G_c = 1.
    poss := [ t : t in CartesianProduct(axis_stabilisers) ];
    no_actions +:= #poss;
    poss2 := [ t : t in poss | IsFaithfulAction(G, [t[1], t[2], t[3]])];
    poss3 := [ t : t in poss2 | StabiliserNotTooLarge(G, t, s)];
    not_faithful_stab +:= #poss-#poss2;
    stab_too_large +:= #poss2-#poss3;
    
    for stab in poss3 do
      O := [<Ax, tau> where Ax, tau := ConjugacyAction(G, stab[i], s[i]) : i in [1..3]];      
      
      // We use Lemma 4.9 again
      if exists(err){ <x,y,i,j> : x in O[i,1], y in O[j,1], i,j in [1..3] | (y@O[j,2] in Stabiliser(G, O[i,1], x)) ne (x@O[i,2] in Stabiliser(G, O[j,1], y))} then
        not_symmetric +:= 1;
        continue stab;
      end if;
      
      // can only collapse axes when both the orbits size on axes is the same and set of involutions given by the tau map is the same.
      multi := {* <orbs[i], #O[i,1]> : i in [1..3] *};
      
      if #Multiplicities(multi) eq 1 then
        // all three orbits on both involutions and axes are the same
        // Don't need to check for 5A or 6A as there is only one orbit
        assert IsAdmissibleTauMap(O[1,1], O[1,2]);
        DedupeAppend(~out, O[1,1]); // We don't care about the tau map
        
        // We must check for 2, or 3 orbits
        if not IsUnique(G, s[1]) then
          Ax, tau := SumActions(O[1,1], O[1,2], O[2,1], O[2,2]);
          assert IsAdmissibleTauMap(Ax, tau);
          assert not Has6A5A(Ax, tau);
          DedupeAppend(~out, Ax); // We don't care about the tau map

          Ax, tau := SumActions(Ax, tau, O[3,1], O[3,2]);
          assert IsAdmissibleTauMap(Ax, tau);
          assert not Has6A5A(Ax, tau);
          DedupeAppend(~out, Ax); // We don't care about the tau map
        end if;
      
      elif #Multiplicities(multi) eq 2 then
        // there is an orbit which is doubled up
        assert exists(i){ i : i in [1..3] | Multiplicity(multi, <orbs[i], #O[i,1]>) eq 1};
        assert exists(j){ j : j in [1..3] | Multiplicity(multi, <orbs[j], #O[j,1]>) eq 2};
        
        Ax, tau := SumActions(O[i,1], O[i,2], O[j,1], O[j,2]);
        assert IsAdmissibleTauMap(Ax, tau);
        assert not Has6A5A(Ax, tau);
        DedupeAppend(~out, Ax); // We don't care about the tau map
        if not IsUnique(G, s[j]) then
          Ax, tau := SumActions(Ax, tau, O[j,1], O[j,2]);
          assert IsAdmissibleTauMap(Ax, tau);
          assert not Has6A5A(Ax, tau);
          DedupeAppend(~out, Ax); // We don't care about the tau map
        end if;
      else
        // All orbits are different
        Ax, tau := SumActions(O[1,1], O[1,2], O[2,1], O[2,2]);
        Ax, tau := SumActions(Ax, tau, O[3,1], O[3,2]);
        assert IsAdmissibleTauMap(Ax, tau);
        assert not Has6A5A(Ax, tau);
        DedupeAppend(~out, Ax); // We don't care about the tau map
      end if;
    end for;
  end for;    
  return out, no_actions, not_faithful_min, not_faithful_stab, stab_too_large, not_symmetric;
end function;

possibles, no_actions, not_faithful_min, not_faithful_stab, stab_too_large, not_symmetric := BuildGX(all_groups);


Sort(~possibles, func<x,y | Order(Group(x)) ne Order(Group(y))
                            select Order(Group(x)) - Order(Group(y))
                            else #x-#y>);

[<GroupName(Group(possibles[i])), [#o : o in Orbits(Group(possibles[i]), possibles[i])], #Shapes(possibles[i], tau, stab)> where tau, stab := Explode(AdmissibleTauMaps(possibles[i])[1]) : i in [1..#possibles]];


string := "group_list := [";
for i in [1..#possibles] do
  G := Group(possibles[i]);
  string cat:= Sprintf("sub< Sym(%o) | [ %o, %o, %o]>,\n", Degree(G), Eltseq(G.1), Eltseq(G.2), Eltseq(G.3));
end for;
string := string[1..#string-2] cat "];";
Write("3gen4trans_group_list.m", string);

its := func<x|IntegerToString(x)>;
tab:="";
for i in [1..#possibles] do
  Ax := possibles[i];
  G := Group(Ax);
  tau, stab := Explode(AdmissibleTauMaps(Ax)[1]);
  info := [ "$" cat GroupName(G:TeX:=true) cat "$", Join([its(#o) : o in Orbits(G, Ax)], "+"), its(#Shapes(Ax, tau, stab))];
  tab cat:= Join(info, " & ") cat "\\\\\n";
end for;

Write("3gen4trans_actions.tex", tab);
